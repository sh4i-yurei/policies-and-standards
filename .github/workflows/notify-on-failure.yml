# CI failure notification — STD-030
#
# Reusable workflow that notifies on CI failures.
# Two notification channels:
# 1. GitHub issue (default) — no external dependencies
# 2. Webhook (optional) — Slack-compatible JSON payload
#
# Called by other workflows or as a standalone notification
# for post-merge and scheduled runs.
#
# CALLER PERMISSIONS: The calling workflow must grant
# `issues: write` permission for issue creation to work.
# Without it, the create-issue job will fail silently.

name: "Notify on Failure"

on:
  workflow_call:
    inputs:
      gate-name:
        description: "Name of the failed gate or check"
        required: true
        type: string
      pr-number:
        description: "PR number (if applicable)"
        required: false
        type: string
        default: ""
      error-summary:
        description: >-
          Brief description of the failure. Defaults to
          a generic message if omitted.
        required: false
        type: string
        default: "CI gate failed. Check the run logs."
      severity:
        description: "Failure severity (required|advisory)"
        required: false
        type: string
        default: "required"
      create-issue:
        description: "Create a GitHub issue for the failure"
        required: false
        type: boolean
        default: true
      send-webhook:
        description: >-
          Send a Slack-compatible webhook notification.
          Requires CI_NOTIFY_WEBHOOK secret. Other consumers
          (Discord, Teams) may need an adapter.
        required: false
        type: boolean
        default: false
    secrets:
      CI_NOTIFY_WEBHOOK:
        description: >-
          Webhook URL for Slack-compatible notifications.
          Other consumers may need a format adapter.
        required: false

jobs:
  create-issue:
    name: "Create failure issue"
    if: inputs.create-issue && inputs.severity == 'required'
    runs-on: ubuntu-latest
    permissions:
      issues: write
    steps:
      - name: Create or update failure issue
        uses: actions/github-script@v7
        env:
          INPUT_GATE: ${{ inputs.gate-name }}
          INPUT_PR: ${{ inputs.pr-number }}
          INPUT_SUMMARY: ${{ inputs.error-summary }}
          INPUT_SEVERITY: ${{ inputs.severity }}
        with:
          script: |
            const gate = process.env.INPUT_GATE;
            const pr = process.env.INPUT_PR;
            const summary = process.env.INPUT_SUMMARY;
            const severity = process.env.INPUT_SEVERITY;
            const sha = context.sha.substring(0, 7);
            const runUrl = [
              context.serverUrl,
              context.repo.owner,
              context.repo.repo,
              'actions/runs',
              context.runId
            ].join('/');

            const prRef = pr ? ` (PR #${pr})` : '';
            const title = `CI failure: ${gate}${prRef}`;

            // Deduplicate: search for existing open issue
            const query = [
              `repo:${context.repo.owner}/${context.repo.repo}`,
              'is:issue',
              'is:open',
              `"CI failure: ${gate}"`
            ].join(' ');

            const search =
              await github.rest.search.issuesAndPullRequests({
                q: query,
                per_page: 5
              });

            const dup = search.data.items.find(i =>
              i.title.startsWith(`CI failure: ${gate}`)
            );

            if (dup) {
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: dup.number,
                body: [
                  `**Repeated failure** at ${sha}`,
                  `Run: ${runUrl}`,
                  `Summary: ${summary}`
                ].join('\n')
              });
              core.info(`Updated issue #${dup.number}`);
              return;
            }

            const body = [
              `## CI failure: ${gate}`,
              '',
              '| Field | Value |',
              '|-------|-------|',
              `| Gate | ${gate} |`,
              pr ? `| PR | #${pr} |` : null,
              `| Commit | ${sha} |`,
              `| Severity | ${severity} |`,
              `| Run | [Logs](${runUrl}) |`,
              '',
              '### Error summary',
              '',
              summary,
              '',
              '### Resolution',
              '',
              'Per STD-030: required gate failures are',
              'release-blocking and must be remediated.',
              'Check the run logs.',
              '',
              '---',
              '*Auto-created by CI notification.*'
            ].filter(Boolean).join('\n');

            // Use labels that exist in repo; skip gracefully
            const labels = [];
            try {
              await github.rest.issues.getLabel({
                owner: context.repo.owner,
                repo: context.repo.repo,
                name: 'type:ci'
              });
              labels.push('type:ci');
            } catch {
              core.warning('Label type:ci not found');
            }
            if (severity === 'required') {
              try {
                await github.rest.issues.getLabel({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  name: 'priority:high'
                });
                labels.push('priority:high');
              } catch {
                core.warning('Label priority:high not found');
              }
            }

            await github.rest.issues.create({
              owner: context.repo.owner,
              repo: context.repo.repo,
              title: title,
              body: body,
              labels: labels
            });

  send-webhook:
    name: "Send webhook notification"
    if: inputs.send-webhook
    runs-on: ubuntu-latest
    steps:
      - name: Send webhook
        env:
          WEBHOOK_URL: ${{ secrets.CI_NOTIFY_WEBHOOK }}
          INPUT_GATE: ${{ inputs.gate-name }}
          INPUT_PR: ${{ inputs.pr-number }}
          INPUT_SUMMARY: ${{ inputs.error-summary }}
          INPUT_SEVERITY: ${{ inputs.severity }}
          GITHUB_SHA_FULL: ${{ github.sha }}
          GITHUB_REPO: ${{ github.repository }}
          GITHUB_RUN: ${{ github.run_id }}
          GITHUB_SRV: ${{ github.server_url }}
        run: |
          if [ -z "$WEBHOOK_URL" ]; then
            echo "::warning::No CI_NOTIFY_WEBHOOK secret"
            exit 0
          fi

          SHORT_SHA="${GITHUB_SHA_FULL:0:7}"
          RUN_URL="${GITHUB_SRV}/${GITHUB_REPO}/actions/runs/${GITHUB_RUN}"

          PR_REF=""
          if [ -n "$INPUT_PR" ]; then
            PR_REF=" (PR #${INPUT_PR})"
          fi

          # Slack-compatible JSON payload. Other webhook
          # consumers (Discord, Teams) may need an adapter
          # to transform this format.
          PAYLOAD=$(jq -n \
            --arg text "CI failure: ${INPUT_GATE}${PR_REF}" \
            --arg repo "$GITHUB_REPO" \
            --arg sha "$SHORT_SHA" \
            --arg sev "$INPUT_SEVERITY" \
            --arg url "$RUN_URL" \
            --arg sum "$INPUT_SUMMARY" \
            '{
              text: $text,
              blocks: [
                {
                  type: "section",
                  text: {
                    type: "mrkdwn",
                    text: ("*" + $text + "*")
                  }
                },
                {
                  type: "section",
                  fields: [
                    {type:"mrkdwn",text:("*Repo:*\n"+$repo)},
                    {type:"mrkdwn",text:("*Commit:*\n"+$sha)},
                    {type:"mrkdwn",text:("*Severity:*\n"+$sev)},
                    {type:"mrkdwn",text:("*Logs:*\n<"+$url+"|View>")}
                  ]
                },
                {
                  type: "section",
                  text: {
                    type: "mrkdwn",
                    text: ("*Summary:*\n" + $sum)
                  }
                }
              ]
            }')

          HTTP_CODE=$(curl -s -o /dev/null \
            -w "%{http_code}" \
            -X POST \
            -H "Content-Type: application/json" \
            -d "$PAYLOAD" \
            "$WEBHOOK_URL")

          if [ "$HTTP_CODE" -ge 200 ] && \
             [ "$HTTP_CODE" -lt 300 ]; then
            echo "Webhook sent (HTTP $HTTP_CODE)"
          else
            echo "::warning::Webhook HTTP $HTTP_CODE"
            sleep 2
            curl -s -X POST \
              -H "Content-Type: application/json" \
              -d "$PAYLOAD" \
              "$WEBHOOK_URL" || true
          fi
